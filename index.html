<!DOCTYPE html>
<html>
    <head>
        <title id = "title"> Carom Board </title>
        <script src = "js/three.min.js" type = "text/javascript" > </script>
        <script src = "js/THREEx.KeyboardState.js" type = "text/javascript" ></script> 
        <script src = "js/KeyboardState.js" type = "text/javascript"> </script>
    </head>
    <body>
        <script type = "text/javascript">
            
            var WIDTH = 1000;
            var HEIGHT = 800;

            //camera attributes
            var VIEW_ANGLE = 45,
            ASPECT = WIDTH/HEIGHT,
            NEAR = 0.1,
            FAR = 10000;

            //creating a raycaster
            var raycaster = new THREE.Raycaster();
            var mouse = new THREE.Vector2();

            var keyboard = new KeyboardState();
           // var keyboard2 = new THREEx.KeyboardState();
            
            //create webgl renderer, camera and scene
            var renderer = new THREE.WebGLRenderer(
                    {
                        alpha:true
                    });
            var camera = new THREE.PerspectiveCamera(
                    45,
                    ASPECT,
                    NEAR,
                    FAR);
            

            
            var scene = new THREE.Scene();
            var caromFrame = {};
            var coins = [];
            var striker ;
            //to remove the sticking effect from collisions ; making them better
            var coinPossibleCollision = [];
            var strikerPossibleCollisionWithCoins=[];
            var coinPossibleWalls = [];
            var strikerPossibleCollisionWalls = 0;

            //score
            var SCORE = 100;

            function init() {
                addCaromFrame();
                addInitCoins();
                //     playerView();
                scene.add(camera);
                //pull the camera back
                camera.position.z = 400;

                //start the renderer
                renderer.setSize(WIDTH, HEIGHT);

                //attach the renderer-supplied DOM element
                document.body.appendChild( renderer.domElement);

            
                //addCaromFrame();
                //addInitCoins();
                //            resetStriker();
            
                var pointLight = new THREE.PointLight(0xFFFFFF);

                pointLight.position.x = 10;
                pointLight.position.y = 50;
                pointLight.position.z = 130;

                scene.add(pointLight);
               // console.log("hello there");
            }

            function addCaromFrame() {

                //drawing side walls
                var xs = [20, 200, 20, 200];
                var ys = [200, 20, 200, 20];
                var positionx = [-100, 0, 100, 0];
                var positiony = [0, 100, 0, -100];
                caromFrame.corners = [];
                for( var i = 0; i< 4; i++) {
                    caromFrame.corners[i] = new THREE.Mesh(
                        new THREE.CubeGeometry(
                            xs[i],
                            ys[i],
                            20), new THREE.MeshLambertMaterial(
                            {
                                color: 0xFFFF00
                            })
                        );
                    caromFrame.corners[i].position.x = positionx[i];
                    caromFrame.corners[i].position.y = positiony[i];
                    scene.add(caromFrame.corners[i]);
                } 
                
                //drawing base of board
                caromFrame.base = new THREE.Mesh(
                        new THREE.CubeGeometry(
                            200,
                            200,
                            10 ), new THREE.MeshLambertMaterial(
                                {
                                    color : 0xFFFF99
                                })
                                
                        );
                caromFrame.base.position.z = -10;
                scene.add(caromFrame.base);

                //drawing the end pockets
                var positionx = [-78, 78, 78, -78];
                var positiony = [78, 78, -78, -78];
                caromFrame.circle = [];

                for( var i = 0; i<4; i++) {
                    caromFrame.circle[i] = new THREE.Mesh(
                        new THREE.CircleGeometry(
                            10,
                            20), new THREE.MeshLambertMaterial(
                            {
                                color: 0xFFA3E6
                            })
                        );
                    caromFrame.circle[i].position.x = positionx[i];
                    caromFrame.circle[i].position.y = positiony[i];
                    caromFrame.circle[i].position.z = -5;
                    scene.add(caromFrame.circle[i]);
                }

                //drawing the rectangular lines
                var vertex = [[-65, 65], [65, 65], [65, -65], [-65,-65] ];
                var tempShape = new THREE.Shape();
                tempShape.moveTo(-65, -65);
                for( i =0; i< 4; i++) {
                    tempShape.lineTo( vertex[i][0], vertex[i][1]);
                }
                var tempGeom = new THREE.ShapeGeometry(tempShape);
                caromFrame.centreRect = new THREE.Mesh(tempGeom, new THREE.MeshLambertMaterial( 
                    {
                        color: 0x000000
                    })
                );
                caromFrame.centreEdges = new THREE.EdgesHelper(caromFrame.centreRect, 0x000000);
                scene.add(caromFrame.centreEdges);
                
                //drawing the centre circle 
            
                caromFrame.centreCircle = new THREE.Mesh(
                    new THREE.CircleGeometry(
                        35,
                        400), new THREE.MeshLambertMaterial(
                        {
                            color: 0x000000
                        })
                    );
                caromFrame.centreCircleEdges = new THREE.EdgesHelper(
                    caromFrame.centreCircle, 0x000000);
                scene.add(caromFrame.centreCircleEdges);
                       
            }

            function addInitCoins() {
                var radius = 5, height = 5;
                //add queen
                var temp = new THREE.Mesh(
                    new THREE.CylinderGeometry(
                        radius, 
                        radius,
                        height,
                        40), new THREE.MeshLambertMaterial(
                        {
                            color: 0xFF0000
                        })
                    );
                //temp.position.z = 10;
                temp.position.x = 0;
                temp.position.y =0;
                temp.rotation.x = 90;
                temp.position.z = -3;
                temp.velx = 0;
                temp.vely = 0;
                temp.power = 0;
                temp.theta = 0;
                temp.col = "red";
                temp.isRemoved = 0;
                scene.add(temp);
                coins.push(temp);

                var innerRad = 12;
                var theta = 0;
                for(i = 0; i<2; i++) {
                    if( i===0 ) {
                        innerRad = 12;
                        init = 0;
                        inc = 60;
                    }
                    else {
                        innerRad = 25;
                        init = 90;
                        inc = 30;
                    }
                    for( theta = init, ct = 0; theta < init+360; theta += inc, ct++) {
                        if (ct % 2 === 0) col = 0x000000;
                        else col = 0xFFFFFF;
                        var temp = (Math.PI / 180)*theta;
                        var circle = new THREE.Mesh(
                            new THREE.CylinderGeometry(
                                radius,
                                radius,
                                height,
                                40), new THREE.MeshLambertMaterial(
                                {
                                    color: col
                                })
                            );
                    //  circle.position.z
                        circle.position.x = innerRad* Math.sin(temp);
                        circle.position.y = innerRad* Math.cos(temp);
                        circle.rotation.x = 90;
                        circle.position.z = -3
                        circle.power = 0;
                        circle.velx = 0;
                        circle.vely = 0;
                        circle.theta = 0;
                        if( col == 0xFFFFFF)
                            circle.col = "white";
                        else
                            circle.col = "black";
                        circle.isRemoved = 0;
                        scene.add(circle);
                        coins.push(circle); 
                    }
                }

                striker = new THREE.Mesh(
                    new THREE.CylinderGeometry(
                        8,
                        8,
                        7,
                        40), new THREE.MeshLambertMaterial(
                        {
                            color: 0x00FF00
                        })
                    );
                striker.rotation.x = 90;
                scene.add(striker);
                resetStriker();

                //initializing the collision smoothing vectors
                for( var i = 0; i < coins.length; i++ ) {
                    var temp = [];
                    for( var j = 0; j < coins.length; j++ ) {
                        temp.push(0);
                    }
                    coinPossibleCollision.push(temp);
                }

                for( var i = 0; i < coins.length; i++ ) {
                    coinPossibleWalls.push(0);
                }

                strikerPossibleCollisionWalls = 0;

                //var temp = [];
                for(var i = 0; i < coins.length; i++ ) {
                    strikerPossibleCollisionWithCoins.push(0);
                }
            }

            function resetStriker () {
                console.log("hello");
                striker.position.y = -60;
                striker.position.x = 0;
                striker.isMoving = 0;
                striker.velx = 0;
                striker.vely = 0;
                striker.power = 0;
                striker.theta = 30;
                var angle = (Math.PI/180 )*30;
                var geometry = new THREE.Geometry();
                geometry.vertices.push(new THREE.Vector3(striker.position.x, striker.position.y, 0));
                geometry.vertices.push(new THREE.Vector3(striker.position.x + 40*Math.cos(angle), striker.position.y + 40*Math.sin(angle), 0));
                striker.line = new THREE.Line(
                    geometry, new THREE.LineBasicMaterial (
                    {
                        color: 0x0000ff
                    })
                );
                scene.add(striker.line);
            }

            function checkCollissionWithWalls(striker, dist) {
                //collision with left
                if( Math.abs(caromFrame.corners[0].position.x - striker.position.x) < dist || Math.abs(caromFrame.corners[2].position.x - striker.position.x) < dist) {
                   // console.log("What the hell");
                    striker.theta = 180 - striker.theta;
                    return 1;
                }

                if(Math.abs(caromFrame.corners[1].position.y - striker.position.y) < dist || Math.abs(caromFrame.corners[3].position.y - striker.position.y )< dist) {
                   // console.log("what the double hell");
                    striker.theta = 360 - striker.theta;
                    return 1;
                }

                return 0;
            }

            function checkOutWalls(circle, dist) {
                if( Math.abs(caromFrame.corners[0].position.x - striker.position.x) > dist && Math.abs(caromFrame.corners[1].position.y - striker.position.y) > dist && Math.abs(caromFrame.corners[2].position.x - striker.position.x) > dist && Math.abs(caromFrame.corners[3].position.y - striker.position.y) > dist) {
                    return 1;
                }
                return 0;
            }

            function checkCollission(circle1, circle2, dist) {
                var x1 = circle1.position.x;
                var x2 = circle2.position.x;
                var y1 = circle1.position.y;
                var y2 = circle2.position.y;

                if( Math.abs(Math.sqrt((x1 -x2)*(x1-x2) + (y1 - y2)*(y1-y2))) < dist) {
                    //console.log("collision detected");

                    collideObject(circle1, circle2);
                    return 1;
                }
                return 0;
            }

            function checkDist(circle1, circle2) {
                var x1 = circle1.position.x;
                var y1 = circle1.position.y;
                var x2 = circle2.position.x;
                var y2 = circle2.position.y;

                return Math.sqrt((x1-x2)*(x1-x2)  + (y1-y2)*(y1-y2)); 
            }

            function collideObject(circle1, circle2) {
                console.log(circle1, circle2);
                var angleOfCollision = (180/Math.PI)*Math.atan((circle2.position.y - circle1.position.y)/(circle2.position.x - circle1.position.x));

                var angle1 = circle1.theta - angleOfCollision;
                var angle2 = circle2.theta - angleOfCollision;

                var v1 = circle1.power;
                var v2 = circle2.power;
                var e = 0.8;
                var v2x = 1/2*((1+e)*v1*Math.cos((Math.PI/180)*angle1) + (1-e)*v2*Math.cos((Math.PI/180)*angle2));
                var v1x = 1/2*((1-e)*v1*Math.cos((Math.PI/180)*angle1) + (1+e)*v2*Math.cos((Math.PI/180)*angle2));

                var v1y = v1*Math.sin((Math.PI/180)*angle1);
                var v2y = v2*Math.sin((Math.PI/180)*angle2);

                circle1.power = Math.sqrt( v1x*v1x + v1y*v1y);
                circle2.power = Math.sqrt( v2x*v2x + v2y*v2y);

                circle1.theta = angleOfCollision + (180/Math.PI)*Math.atan(v1y/v1x);
                circle2.theta = angleOfCollision + (180/Math.PI)*Math.atan(v2y/v2x);

            }

            function update() {
                keyboard.update();

                if(strikerPossibleCollisionWalls === 0) {
                    var flag = checkCollissionWithWalls(striker, 18);
                    if(flag === 1) {
                        strikerPossibleCollisionWalls = 1;
                    }
                }
                else {
                    if( checkOutWalls(striker, 19) ) {
                        strikerPossibleCollisionWalls = 0;
                    }
                }


                for(var i=0; i<4; i++) {
                    if(checkCollission(striker, caromFrame.circle[i], 10)) {

                        console.log("out ho gya bete");
                        SCORE -= 5;
                        resetStriker(); 
                    }
                }
                for( var i =0; i<coins.length; i++) {
                    if( coins[i].isRemoved === 1 )
                        continue;
                    if( coinPossibleWalls[i] === 0 ) {
                        var flag = checkCollissionWithWalls(coins[i], 15);
                        if(flag === 1) {
                            coinPossibleWalls[i] = 1;
                        }
                    }
                    else {
                        if( checkOutWalls(coins[i], 16) ) {
                            coinPossibleWalls[i] = 0;
                        }
                    }
                }

                for( var i = 0; i<coins.length; i++) {

                    if( coins[i].isRemoved === 1)
                        continue;

                    if(strikerPossibleCollisionWithCoins[i] === 0) {
                        var flag = checkCollission(striker, coins[i], 13);
                        if( flag === 1) {
                            strikerPossibleCollisionWithCoins[i] = 1;
                        }
                    }   
                    else {
                        if(checkDist(striker, coins[i]) > 13) {
                            strikerPossibleCollisionWithCoins[i] = 0;
                        }
                    }
                }

                for( var i = 0; i < coins.length; i++ ) {

                    if( coins[i].isRemoved === 1)
                        continue;

                    for( var j = 0; j < 4; j++) {
                        if( checkCollission(coins[i], caromFrame.circle[j], 7 ) ) {
                            scene.remove(coins[i]);
                            coins[i].isRemoved = 1;
                            if( coins[i].col == "white" ) {
                                SCORE += 5;
                            }
                            else
                                SCORE -= 20;

                            break;
                        }
                    }
                }

                for(var i = 0; i < coins.length; i++) {
                    if( coins[i].isRemoved === 1) 
                        continue;

                    for(j = 0; j<coins.length; j++) {
                        if ( coins[j].isRemoved === 1)
                            continue;

                        if(i!=j) {
                            if( coinPossibleCollision[i][j] === 0) {
                                var flag = checkCollission(coins[i], coins[j], 10);
                                if( flag === 1) {
                                    coinPossibleCollision[i][j] = 1;
                                }
                            }
                            else {
                                if(checkDist(coins[i], coins[j]) > 10) {
                                    coinPossibleCollision[i][j] = 0;
                                }
                            }
                        }
                    }
                }

                if(striker.isMoving && striker.power > 0 ){
                    if(striker.position.x  >= 90 && striker.velx > 0) {

                    }
                    else if( striker.position.x <= -90 && striker.velx < 0 ) {

                    }
                    else {
                    var angle = (Math.PI/180)*striker.theta;

                    striker.translateX(striker.power*Math.cos(angle));
                    striker.translateY(-1*striker.power*Math.sin(angle));
                    striker.position.z = -3;
                    }
                    striker.power -= 0.02;
                }

                if(striker.isMoving && striker.power <= 0 ) {
                    console.log("the striker ceized");
                    resetStriker();
                }

                for( var i = 0; i< coins.length; i++) {
                  //  if(Math.abs(coins[i].position.x) <= 87 && Math.abs(coins[i].position.y) <= 87) {
                    if(coins[i].isRemoved === 1)
                        continue;

                    if(coins[i].position.x  >= 90 && coins[i].velx > 0) {
                        coins[i].theta += 90;


                    }
                    else if( coins[i].position.x <= -90 && coins[i].velx < 0 ) {
                            coins[i].theta -= 90;
                    }
                    else {
                        var angle = (Math.PI/180)*coins[i].theta;
                        coins[i].translateX(coins[i].power*Math.cos(angle));
                        coins[i].translateY(-1*coins[i].power*Math.sin(angle));
                        coins[i].position.z = -3;
                    }
                    
                    if(coins[i].power > 0)
                        coins[i].power -= 0.02;

                }

              //  console.log("hello");
                if(keyboard.pressed("left")) {
                    //console.log("balle balle");
                    if(striker.position.x > -65) {
                        striker.translateX(-1);
                        striker.line.translateX(-1);
                    }

                }

                if(keyboard.pressed("right")) {
                    if(striker.position.x < 65){
                        striker.translateX(1);
                        striker.line.translateX(1);
                    }
                }

                if(keyboard.pressed("A") && striker.theta < 180) {
                    //   console.log ("abe a record ho gya ");
                    //var axis = new THREE.Vector3(0,0,1);
                    //var angle = Math.PI/150;
                    //striker.line.applyAxisAngle(axis, angle);
                    scene.remove(striker.line);
                    striker.theta += 1;
                  //  striker.line.rotation.x = 10;
                    var angle = (Math.PI/180 )*striker.theta;
                    var geometry = new THREE.Geometry();
                    geometry.vertices.push(new THREE.Vector3(striker.position.x, striker.position.y, 0));
                    geometry.vertices.push(new THREE.Vector3(striker.position.x + 40*Math.cos(angle), striker.position.y + 40*Math.sin(angle), 0));
                    striker.line = new THREE.Line(
                        geometry, new THREE.LineBasicMaterial (
                        {
                            color: 0x0000ff
                        })
                    );
                    scene.add(striker.line);
                }

                if(keyboard.pressed("D") && striker.theta > 0) {
                    //   console.log ("abe a record ho gya ");
                    //var axis = new THREE.Vector3(0,0,1);
                    //var angle = Math.PI/150;
                    //striker.line.applyAxisAngle(axis, angle);
                    scene.remove(striker.line);
                    striker.theta -= 1;
                  //  striker.line.rotation.x = 10;
                    var angle = (Math.PI/180 )*striker.theta;
                    var geometry = new THREE.Geometry();
                    geometry.vertices.push(new THREE.Vector3(striker.position.x, striker.position.y, 0));
                    geometry.vertices.push(new THREE.Vector3(striker.position.x + 40*Math.cos(angle), striker.position.y + 40*Math.sin(angle), 0));
                    striker.line = new THREE.Line(
                        geometry, new THREE.LineBasicMaterial (
                        {
                            color: 0x0000ff
                        })
                    );
                    scene.add(striker.line);
                }

                if(keyboard.pressed("Z")) {
                    striker.power += 0.1;
                }

                if(keyboard.down("F")) {
                    if(striker.power > 0) {
                        striker.isMoving = 1;
                        scene.remove(striker.line);
                        var angle = (Math.PI/180)*striker.theta;
                        striker.translateX(striker.power * Math.cos(angle));
                        striker.translateY(-1*striker.power*Math.sin(angle));
                        striker.position.z = -3;
                        console.log( "angle " + striker.theta);
                    }
                }

                document.getElementById('title').innerHTML = "score " + SCORE;
            }

            function render() {
                // //update the picking ray with the camera and mouse position
                // raycaster.setFromCamera(mouse, camera);

                // //calculate objects intersecting the picking ray
                // var intersects = raycaster.intersectObjects(scene.children);

                // for( var i = 0; i < intersects.length; i++ ) {
                //     intersects[i].object.material.color.set(0xff0000);
                //     console.log(intersects[i]);
                // }
                update();
                renderer.setClearColor(0xFFFFFF, 0);
                renderer.render(scene, camera);
            }

            function playerView() {
                camera.position.set(0, -300, 300);
                camera.up = new THREE.Vector3(0,0,1);
                camera.lookAt(new THREE.Vector3(0,0,0));
            }

            function animate() {
                requestAnimationFrame(animate);
                render();
                update();
            }



            init();
            animate();
            
        </script>
    </body>
</html>
